`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2021/10/12 15:11:15
// Design Name: 
// Module Name: try_tb
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module cpu_tb();

reg clk;
reg wea;
reg [31:0] dinaddr;
reg [31:0] dina;

wire [4:0]  waddr,raddr1,raddr2;
wire [31:0] rtt1;
wire [31:0] rtt2;
wire [4:0] ALU_op;
wire regfile_op;
wire [31:0] order;
wire ch;
wire [31:0] addra;
wire [31:0] ch_addr;
wire [31:0] oldaddr;
wire [31:0] jor_addr;

cpu uut(
    .clk(clk),
    .wea(wea),
    .dinaddr(dinaddr),
    .dina(dina),
    .rtt1(rtt1),
    .rtt2(rtt2),
    .ALU_op(ALU_op),
    .regfile_op(regfile_op),
    .waddr(waddr),
    .raddr1(raddr1),
    .raddr2(raddr2),
    .order(order),
    .addra(addra),
    .ch_addr(ch_addr),
    .oldaddr(oldaddr),
    .jor_addr(jor_addr),
    .ch(ch)
);

initial begin
    clk = 1'b0;
    wea = 1'b1;
    
    // 注意前边的用的LUI是高16位为0，低位赋16位立即数，最后才是真正的LUI指令
    /*
    //测试 指令RAM，ALU和regfile的正常工作 ADDU LUI AND
    #10;
    dinaddr = 32'b1;
    dina = 32'b00111100000000010000000000111011; // 指令1 lui 1：3Bh，59;
    #20;
    dinaddr = 32'b10;
    dina = 32'b00111100000000100000000000100101; // 指令2 lui 2：25h，37; 
    #20;
    dinaddr = 32'b11;
    dina = 32'b00000000001000100000100000100001; // 指令3 addu 1+2 > 1;
    #20;
    dinaddr = 32'b100; 
    dina = 32'b00000000001000100001000000100100; // 指令4 and 1&2 > 2;
    #20;
    */
    /*
    //测试 NOR OR XOR
    #10;
    dinaddr = 32'b1;
    dina = 32'b00111100000001000000000000111011; // 指令1 lui 4：3Bh，59;
    #20;
    dinaddr = 32'b10;
    dina = 32'b00111100000000110000000000100101; // 指令2 lui 3：25h，37;
    #20;
    dinaddr = 32'b11;
    dina = 32'b00000000011001000000100000100111; // 指令3 3和4或非结果到1 nor
    #20;
    dinaddr = 32'b100; 
    dina = 32'b00000000011001000001000000100101; // 指令4 3和4或结果到2 or
    #20;
    dinaddr = 32'b101; 
    dina = 32'b00000000011001000000100000100110; // 指令5 3和4异或结果到1 xor
    #20;
    */
    /*
    //测试 指令 SUBU
    #10;
    dinaddr = 32'b1;
    dina = 32'b00111100000000010000000000111011; // 指令1 lui 1：3Bh，59;
    #20;
    dinaddr = 32'b10;
    dina = 32'b00111100000000100000000000100101; // 指令2 lui 2：25h，37; 
    #20;
    dinaddr = 32'b11;
    dina = 32'b00000000001000100001000000100011; // 指令3 subu 寄存器1-寄存器2的结果存到寄存器2中
    #20;
    */
    /*
    //测试 指令 SLL SRA SRL
    #10;
    dinaddr = 32'b1;
    dina = 32'b00111100000000101111111111111010; // 指令1 lui 2：FFFAh，-6; 
    #20;
    dinaddr = 32'b10;
    dina = 32'b00000000000000100000100010000000; // 指令2 SLL; 2 << 2位 存到 寄存器1中
    #20;
    dinaddr = 32'b11;
    dina = 32'b00000000000000100000100010000011; // 指令3 SRA;算术 2 >> 2位 存到 寄存器1中
    #20;
    dinaddr = 32'b100; 
    dina = 32'b00000000000000100000100010000010; // 指令4 SRL;逻辑 2 >> 2位 存到 寄存器1中 
    #20;
    */
    /*
    //测试 指令 MUL
    #10;
    dinaddr = 32'b1;
    dina = 32'b00111100000000010000000000111011; // 指令1 lui 1：3Bh，59;
    #20;
    dinaddr = 32'b10;
    dina = 32'b00111100000000100000000000100101; // 指令2 lui 2：25h，37; 
    #20;
    dinaddr = 32'b11;
    dina = 32'b01110000001000100000100000000010; // 指令3 mul 1*2 > 1;
    #20;
    */
    /*
    //测试 指令 SLT SLTU
    #10;
    dinaddr = 32'b1;
    dina = 32'b00111100000001000000000000111011; // 指令1 lui 4：3Bh，59;
    #20;
    dinaddr = 32'b10;
    dina = 32'b00111100000000111111111111111010; // 指令2 lui 3：FFFAh，-6; 
    #20;
    dinaddr = 32'b11;
    dina = 32'b00000000011001000000100000101010; // 指令3 SLT; 1 = 3 < 4 ? 1 : 0; 有符号
    #20;
    dinaddr = 32'b100; 
    dina = 32'b00000000011001000001000000101011; // 指令4 SLTU; 2 = 3 < 4 ? 1 : 0; 无符号;
    #20;
    */
    /*
    //测试 ADDIU 
    #10;
    dinaddr = 32'b1;
    dina = 32'b00111100000000010000000000111011; // 指令1 lui 1：3Bh，59;
    #20;
    dinaddr = 32'b10;
    dina = 32'b00100100001000101111111111111010; // 指令2 addiu：寄存器1中的值加FFFAh，-6 存到寄存器2中; 
    #20;
    */
    /*
    // 测试 数据RAM 的读入读出 LW SW
    #10;
    dinaddr = 32'b1;
    dina = 32'b00111100000000010000000000000100; // 指令1 lui 1：4h，4;
    #20;
    dinaddr = 32'b10;
    dina = 32'b00111100000000100000000000100101; // 指令2 lui 2：25h，37; 
    #20;
    dinaddr = 32'b11;
    dina = 32'b10101100001000100000000001100011; // 指令3 SW 将寄存器2的值存入 地址103处 数据RAM
    #20;
    dinaddr = 32'b100; 
    dina = 32'b10001100001000010000000001100011; // 指令4 LW 将数据RAM 地址 103处的值存入寄存器1中
    #20;
    */
    /*
    // 测试 跳转指令的工作正常 JAL
    #10;
    dinaddr = 32'b1;
    dina = 32'b00111100000000010000000000111011; // 指令1 lui 1：3Bh，59;
    #20;
    dinaddr = 32'b10;
    dina = 32'b00111100000000100000000000000001; // 指令2 lui 2：1h，1; 
    #20;
    dinaddr = 32'b11;
    dina = 32'b00000000001000100000100000100001; // 指令3 addu 1+2 > 1;
    #20;
    dinaddr = 32'b100; 
    dina = 32'b00001100000000000000000000000011; // 指令4 JAL 到第三条指令 
    #20;
    */
    /*
    //测试 BNE
    #10;
    dinaddr = 32'b1;
    dina = 32'b00111100000000010000000000111011; // 指令1 lui 1：3Bh，59;
    #20;
    dinaddr = 32'b10;
    dina = 32'b00111100000000100000000000110111; // 指令2 lui 2：37h，55; 
    #20;
    dinaddr = 32'b11;
    dina = 32'b00100100010000100000000000000001; // 指令3 addiu 寄存器2++; 
    #20;
    dinaddr = 32'b100; 
    dina = 32'b00010100001000100000000000000011; // 指令4 BNE; 1不等于2就转移到指令3
    #20;
    */
    /*
    //测试 BEQ
    #10;
    dinaddr = 32'b1;
    dina = 32'b00111100000000010000000000000000; // 指令1 lui 1：0;
    #20;
    dinaddr = 32'b10;
    dina = 32'b00111100000000100000000000110111; // 指令2 lui 2：37h，55; 
    #20;
    dinaddr = 32'b11;
    dina = 32'b00111100000000110000000000111010; // 指令3 lui 3：3ah，58; 
    #20;
    dinaddr = 32'b100;
    dina = 32'b00100100010000100000000000000001; // 指令4 addiu 寄存器2++; 
    #20;
    dinaddr = 32'b101;
    dina = 32'b00010000010000110000000000000111; // 指令5 BEQ 寄存器2等于寄存器3时转移到指令7
    #20;
    dinaddr = 32'b110; 
    dina = 32'b00010100001000100000000000000011; // 指令6 BNE; 1不等于2就转移到指令4
    #20;
    dinaddr = 32'b111;
    dina = 32'b00111100000000010000000000000001; // 指令7 lui 1：1;说明BEQ执行成功
    #20;
    */
    /*
    // 测试 JR
    #10;
    dinaddr = 32'b1;
    dina = 32'b00111100000000010000000000111011; // 指令1 lui 1：3Bh，59;
    #20;
    dinaddr = 32'b10;
    dina = 32'b00111100000000100000000000000011; // 指令2 lui 2：3; 
    #20;
    dinaddr = 32'b11;
    dina = 32'b00100100001000010000000000000001; // 指令3 addiu 寄存器1++; 
    #20;
    dinaddr = 32'b100; 
    dina = 32'b00000000010000000000000000001000; // 指令4 跳转到 寄存器2中的值 地址
    #20;
    */
    /*
    //测试 指令 SRA SRL 和正常 LUI
    #10;
    dinaddr = 32'b1;
    dina = 32'b00111100000000101111111111111010; // 指令1 lui 2：FFFA 0000h，; 
    #20;
    dinaddr = 32'b10;
    dina = 32'b00000000000000100000100010000011; // 指令2 SRA;算术 2 >> 2位 存到 寄存器1中
    #20;
    dinaddr = 32'b11; 
    dina = 32'b00000000000000100000100010000010; // 指令3 SRL;逻辑 2 >> 2位 存到 寄存器1中 
    #20;
    */

    dinaddr = 32'b11111111111111111111111111111111;
    dina = 32'b0;
    #20;
    wea = 1'b0; 
    #160;
    $stop;
end

always #10 clk = ~clk;

endmodule
// 测试一下 wea不在上升沿改变的情况 
// 经检验无问题，无论在不在，都是俩个周期后读出第一条指令